
<!doctype html>
<html lang="en-US">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="author" content="Deren Eaton">

  <!-- core, theme, and additional CSS styling -->
  <link rel="stylesheet" href="../revealjs/dist/reset.css">    
  <link rel="stylesheet" href="../revealjs/dist/reveal.css">  
  <link rel="stylesheet" href="../../stylesheets/slides.css">  
  <link rel="stylesheet" href="../revealjs/plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">

      <section>
        <div style="margin-left: auto; margin-top: 15%">
          <h2 class="title" style="color:#5ab4ac;line-height: 1.25">
            Programming and Data Science for Biology<br>(EEEB G4050)</h2>
          <h4 style="color:grey; font-weight: 400; line-height: 1.5"> 
            <i>Lecture 2: Program design</i></h4>
        </div>
      </section>


      <section>
        <div class="standard">
          <h3 class="title">Lecture outline</h3>
          <ul class="bulletbox" style="margin-left: 22%; font-size: 50px">
            <li>review and introduce new terminal basics</li>
            <li>overview of types of software</li>
          </ul>
        </div>
      </section>


    <!-- =================================================================================================================== -->
    <!-- ===== MY SOFTWARE ================================================================================================= -->
    <!-- =================================================================================================================== -->


      <section>
        <section>
          <div class="standard">
            <h3 class="title">Bash review: Filesystem</h3>
          </div>
        </section>
        
        <section>            
          <div class="standard">
            <h3 class="title">The hierarchical unix filesystem</h3>
            <div class="textbox"><p style="text-align: center;">
              Where are my files? Where am I?
            </p></div>
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              ls
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              data/    docs/    file.txt
            </code></pre>                
          </div>
        </section>

        <section>            
          <div class="standard">
            <h3 class="title">The hierarchical unix filesystem</h3>
            <div class="textbox"><p style="text-align: center;">
              Where am I?
            </p></div>
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              pwd
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              /home/deren/
            </code></pre>                
          </div>
        </section>  

        <section>            
          <div class="standard">
            <h3 class="title">The hierarchical unix filesystem</h3>
            <div class="textbox"><p style="text-align: center;">
              what files are in that other directory (using the full path)?
            </p></div>
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              ls /home/deren/Documents/
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              file1.txt    file2.txt    file3.txt
            </code></pre>                
          </div>
        </section>          

        <section>            
          <div class="standard">
            <h3 class="title">The hierarchical unix filesystem</h3>
            <div class="textbox"><p style="text-align: center;">
              what files are in that other directory (using the relative path)?
            </p></div>
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              ls ./Documents/
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              file1.txt    file2.txt    file3.txt
            </code></pre>                
          </div>
        </section>          

        <section>            
          <div class="standard">
            <h3 class="title">The hierarchical unix filesystem</h3>
            <div class="textbox"><p style="text-align: center;">
              what files are in that other directory? (move and then check)
            </p></div>
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              cd /home/deren/Documents/
              ls
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              file1.txt    file2.txt    file3.txt
            </code></pre>                
          </div>
        </section>          

        <section>            
          <div class="standard">
            <h3 class="title">The hierarchical unix filesystem</h3>
            <div class="textbox"><p style="text-align: center;">
              move up one directory (using relative path)
            </p></div>
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              cd ..
              pwd
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              /home/deren/
            </code></pre>                
          </div>
        </section>

        <section>            
          <div class="standard">
            <h3 class="title">The hierarchical unix filesystem</h3>
            <div class="textbox"><p style="text-align: center;">
              list contents of current directory (explicitly)
            </p></div>
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              # three different ways to specify the same
              ls       # . is the default target
              ls .     # . means current dir
              ls ./    # . is a dir, so ./ means the same thing
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              Documents/
            </code></pre>                
          </div>
        </section>      
      </section>

      <!-- ################################### -->
      <!-- ################################### -->
      <!-- ################################### -->

      <section>
        <section>
          <div class="standard">
            <h3 class="title">Bash review: command -options</h3>
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">program -options target</h3>
            <div class="textbox"><p style="text-align: center;">
              use `man` to view documentation of system commands
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              man ls
            </code></pre>                
            <!--  -->
            <pre style="width:60%;"><code data-trim class="language-bash" >
              LS(1)                                    User Commands                                   LS(1)

              NAME
                     ls - list directory contents

              SYNOPSIS
                     ls [OPTION]... [FILE]...

              DESCRIPTION
                     List  information about the FILEs (the current directory by default).  Sort entries al‐
                     phabetically if none of -cftuvSUX nor --sort is specified.

                     Mandatory arguments to long options are mandatory for short options too.

                     -a, --all
                            do not ignore entries starting with .

                     -A, --almost-all
                            do not list implied . and ..

                     --author
                            with -l, print the author of each file

                     -b, --escape
                            print C-style escapes for nongraphic characters

                     --block-size=SIZE
                            with -l, scale sizes by SIZE when printing  them;  e.g.,  '--block-size=M';  see
                            SIZE format below

                     -B, --ignore-backups
                            do not list implied entries ending with ~

                     -c     with  -lt: sort by, and show, ctime (time of last change of file status informa‐
                            tion); with -l: show ctime and sort by name; otherwise: sort  by  ctime,  newest
                            first

                     -C     list entries by columns

                     --color[=WHEN]
                            color the output WHEN; more info below

                     -d, --directory
                            list directories themselves, not their contents

                     -D, --dired
                            generate output designed for Emacs' dired mode

                     -f     list all entries in directory order

                     -F, --classify[=WHEN]
                            append indicator (one of */=>@|) to entries WHEN

                     --file-type
                            likewise, except do not append '*'

                     --format=WORD
                            across -x, commas -m, horizontal -x, long -l, single-column -1, verbose -l, ver‐
                            tical -C

                     --full-time
                            like -l --time-style=full-iso

                     -g     like -l, but do not list owner

                     --group-directories-first
                            group  directories  before files; can be augmented with a --sort option, but any
                            use of --sort=none (-U) disables grouping

                     -G, --no-group
                            in a long listing, don't print group names

                     -h, --human-readable
                            with -l and -s, print sizes like 1K 234M 2G etc.

                     --si   likewise, but use powers of 1000 not 1024

                     -H, --dereference-command-line
                            follow symbolic links listed on the command line

                     --dereference-command-line-symlink-to-dir
                            follow each command line symbolic link that points to a directory

                     --hide=PATTERN
                            do not list implied entries matching shell PATTERN (overridden by -a or -A)

                     --hyperlink[=WHEN]
                            hyperlink file names WHEN

                     --indicator-style=WORD
                            append indicator with style WORD to entry names:  none  (default),  slash  (-p),
                            file-type (--file-type), classify (-F)

                     -i, --inode
                            print the index number of each file

                     -I, --ignore=PATTERN
                            do not list implied entries matching shell PATTERN

                     -k, --kibibytes
                    ...
            </code></pre>                
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">program -options target</h3>
            <div class="textbox"><p style="text-align: center;">
              list contents using 'long list' format (shows time, owner, size...)
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              ls -l 
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              -rw-rw-r-- 1 deren deren     5 Jan 22 22:05 file1.txt
              -rw-rw-r-- 1 deren deren 11141 Jan 22 22:06 file2.txt
              -rw-rw-r-- 1 deren deren  3280 Jan 22 22:07 file3.txt
            </code></pre>
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">program -options target</h3>
            <div class="textbox"><p style="text-align: center;">
              list contents long, sorted by time, using human-readable size.
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              ls -l -t -h  # three options
              ls -lth      # same thing written differently
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              -rw-rw-r-- 1 deren deren 3.3K Jan 22 22:07 file3.txt
              -rw-rw-r-- 1 deren deren  11K Jan 22 22:06 file2.txt
              -rw-rw-r-- 1 deren deren    5 Jan 22 22:05 file1.txt
            </code></pre>
          </div>
        </section>



        <section>
          <div class="standard">
            <h3 class="title">program -options target</h3>
            <div class="textbox"><p style="text-align: center;">
              list files move up one directory (using relative path)
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # program -option target
              ls -ltr /home/deren/work
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              # echo prints the target string to the terminal output (stdout)
              hello world

              # ls -l 'lists' contents in the specifed directory
              drwxr-xr-x  7 deren deren  4096 Dec 28 03:37 data/    
              drwxr-xr-x  7 deren deren  4096 Dec 28 03:37 docs/    
              drwxr-xr-x  7 deren deren  4096 Dec 28 03:37 file.txt
            </code></pre>                
          </div>
        </section>
      </section>


      <!-- ################################### -->
      <!-- ################################### -->
      <!-- ################################### -->

      <section>
        <section>
          <div class="standard">
            <h3 class="title">Bash tricks: efficiency/hotkeys</h3>
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">efficiency/hotkeys</h3>
            <div class="textbox"><p style="text-align: center;">
              ctrl-a returns cursor to the start of a line
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # after writing a long command you notice a typo at the beginning
              lx -ltr /home/deren/work▌
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              # ctrl-a brings cursor back to start.
              ▌lx -ltr /home/deren/work
            </code></pre>                
          </div>
        </section>


        <section>
          <div class="standard">
            <h3 class="title">efficiency/hotkeys</h3>
            <div class="textbox"><p style="text-align: center;">
              ctrl-d deletes a character from cursor position
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # cursor is at beginning of the line
              ▌lx -ltr /home/deren/work
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              # ctrl-d to delete several characters
              ▌ -ltr /home/deren/work
            </code></pre>                
          </div>
        </section>


        <section>
          <div class="standard">
            <h3 class="title">efficiency/hotkeys</h3>
            <div class="textbox"><p style="text-align: center;">
              ctrl-k kills the current line
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # cursor is at beginning of the line
              ▌ls -ltr /home/deren/work
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              # ctrl-k clears the whole line
              ▌
            </code></pre>                
          </div>
        </section>   


        <section>
          <div class="standard">
            <h3 class="title">efficiency/hotkeys</h3>
            <div class="textbox"><p style="text-align: center;">
              ctrl-e sends cursor to end of a line
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # cursor is at beginning of the line
              ▌ls -ltr /home/deren/work
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              # ctrl-e sends it to the end
              ls -ltr /home/deren/work▌
            </code></pre>                
          </div>
        </section>   


        <section>
          <div class="standard">
            <h3 class="title">efficiency/hotkeys</h3>
            <div class="textbox"><p style="text-align: center;">
              ctrl-f and ctrl-b move cursor forward or back one char
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # cursor is at beginning of the line
              ▌ls -ltr /home/deren/work
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              # execute ctrl-f two times
              ls▌ -ltr /home/deren/work
            </code></pre>                
          </div>
        </section>   


        <section>
          <div class="standard">
            <h3 class="title">efficiency/hotkeys</h3>
            <div class="textbox"><p style="text-align: center;">
              the up arrow retrieves previously executed commands; down arrow cycles back.
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # press up once to get last executed command
              pwd
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              # press down key to cycle back down
              ls -ltr /home/deren/work
            </code></pre>                
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">efficiency/hotkeys</h3>
            <div class="textbox"><p style="text-align: center;">
              ctrl-p (previous) and ctrl-n (next) are synonymous with up and down arrows, respectively
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # ctrl-p (move up to previous command)
              pwd
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              # ctrl-n (move down to next command)
              ls -ltr /home/deren/work
            </code></pre>                
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">efficiency/hotkeys</h3>
            <div class="textbox"><p style="text-align: center;">
              ctrl-r allow typing text to interactively search previously executed commands
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # ctr-r then start to type previous command "m"
              m
            </code></pre>                
            <!--  -->
            <pre style="width:60%"><code data-trim class="language-bash">
              # it will autocomplete and cycle among options
              man ls
            </code></pre>                
          </div>
        </section>   


        <section>
          <div class="standard">
            <h3 class="title">efficiency/hotkeys</h3>
            <div class="textbox"><p style="text-align: center;">
              This set of hotkeys is termed the "readline" (or a subset of emacs-style) hotkeys. 
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # ctrl-f: move forward
              a▌aaaa
              # ctrl-b: move back
              ▌aaaaa
              # ctrl-e: move to end
              aaaaa▌
              # ctr-a: move to start
              ▌aaaaa            
              # ctrl-k: clear text after cursor
              ▌
              # ctrl-p: up / previous command 
              man ls
              # ctrl-n: down / next command 
              ▌
            </code></pre>           
          </div>
        </section>
      </section>


      <section>
        <section>
          <div class="standard">
            <h3 class="title">bash tricks: read, write, pipe, redirect</h3>
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">bash tricks: read, write, pipe, redirect</h3>
            <div class="textbox"><p style="text-align: center;">
              `echo` displays/prints a line of text. Useful for debugging; checking variables.
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              echo "hello world"
            </code></pre> 
            <pre style="width:60%"><code data-trim class="language-bash">
              hello world
            </code></pre> 
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">bash tricks: read, write, pipe, redirect</h3>
            <div class="textbox"><p style="text-align: center;">
              `echo` can interpret line breaks and other special characters.
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              echo -e "hello\nworld"
            </code></pre> 
            <pre style="width:60%"><code data-trim class="language-bash">
              hello
              world
            </code></pre> 
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">bash tricks: read, write, pipe, redirect</h3>
            <div class="textbox"><p style="text-align: center;">
              text can be written to files using redirection (> or >>)
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # using > writes so that the file will contain only this text
              echo "hello world" > file.txt
              cat file.txt
            </code></pre> 
            <pre style="width:60%"><code data-trim class="language-bash">
              hello world
            </code></pre> 
            <br>
            <pre style="width:60%"><code data-trim class="language-bash">
              # using >> appends so that the file will add this text to the end
              echo "hello world" >> file.txt
            </code></pre> 
            <pre style="width:60%"><code data-trim class="language-bash">
              hello world
              hello world
            </code></pre>             
          </div>
        </section>      


        <section>
          <div class="standard">
            <h3 class="title">bash tricks: read, write, pipe, redirect</h3>
            <div class="textbox"><p style="text-align: center;">
              `echo` can interpret line breaks and other special characters.
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              echo -e "hello\nworld"
            </code></pre> 
            <pre style="width:60%"><code data-trim class="language-bash">
              hello
              world
            </code></pre> 
          </div>
        </section>     

        <section>
          <div class="standard">
            <h3 class="title">bash tricks: read, write, pipe, redirect</h3>
            <div class="textbox"><p style="text-align: center;">
              `cat` streams (reads) data from a file to the terminal output (stdout)
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              cat file.txt
            </code></pre> 
            <pre style="width:60%"><code data-trim class="language-bash">
              hello world
              hello world
            </code></pre> 
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">bash tricks: read, write, pipe, redirect</h3>
            <div class="textbox"><p style="text-align: center;">
              `cat` concatenates (stitches together) data from multiple files
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              cat file1.txt file2.txt file3.txt > files_123.txt
            </code></pre> 
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">bash tricks: read, write, pipe, redirect</h3>
            <div class="textbox"><p style="text-align: left;">
              `less` shows only single page of text at a time. Allows interactive viewing 
              of files that is much more convenient for viewing large files. 
              <b>You need to press `q` to quit out of the interactive viewing session.</b>
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              less very-large-file.txt
            </code></pre> 
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">bash tricks: read, write, pipe, redirect</h3>
            <div class="textbox"><p style="text-align: center;">
              `grep` is used to perform pattern matching on lines of text.
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # find all lines in this file containing the word "error"
              grep "error" /var/log/auth.log
            </code></pre> 
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">bash tricks: read, write, pipe, redirect</h3>
            <div class="textbox"><p style="text-align: left;">
              A pipe (|) passes the output from command to the input of another 
              command. More specifically, the stdout of a command can become the stdin of
              the next command.
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              echo -e "a\nb\nc" > abc.txt
              cat abc.txt
            </code></pre>
            <pre style="width:60%"><code data-trim class="language-bash">
              a
              b
              c
            </code></pre>
            <div class="textbox"><p style="text-align: center;">
            Here we pipe the output of cat to grep, to search for lines containing 'b'</p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              cat abc.txt | grep b
            </code></pre>
            <pre style="width:60%"><code data-trim class="language-bash">
              b
            </code></pre>
          </div>
        </section>

      </section>


    <!-- INSERT EXAMPLES OF THE TOOLS I HAVE DEVELOPED -->
      <section>

        <section>
          <div class="standard">
            <h3 class="title">Types of software</h3>
          </div>
        </section>

        <section>
          <h3 class="title">Cathedral versus Bazaar</h3>
          <div class="standard-textbox-image">
            <img src="../../assets/images/cathedral.png" class="image"/>
            <div class="textbox"><p>
              Is it better to have one grand monolithic program that does everything (The Cathedral); or numerous independent, microservices that perform one simple thing well (The Bazaar)? This is a classical debate!
            </p></div>
          </div>
        </section>

        <section>
          <div class="standard-10">
            <h3 class="title5">Examples of Cathedrals in Comp. Biology</h3>
            <h4 style="text-align: left; margin-left: 10%; color: orange; margin-top: 2%"> 
              SLiM: Evolutionary Simulation Framework </h4>
            <h4 style="text-align: left; margin-left: 10%; color: orange; margin-top: 2%"> 
              RevBayes: Bayesian Phylogenetic Modeling </h4>
            <ul class="bulletbox">
              <li class="items">A framework that _can_ accomplish many tasks</li>
              <li class="items">Include their own computational languages/syntax</li>
              <li class="items">Huge learning curve & barrier to entry</li>
              <li class="items">Developers require specialized domain expertise</li>
              <li class="items">SLiM Manual is 857 pages</li>
              <li class="items">RevBayes requires an expert tutorial for every analysis</li>
            </ul>
          </div>
        </section>

        <section>
          <div class="standard-10">
            <h3 class="title5">Examples of Bazaars in Comp. Biology</h3>
            <h4 style="text-align: left; margin-left: 10%; color: orange; margin-top: 2%"> 
              Bedtools: genome arithmetic operations</h4>
            <h4 style="text-align: left; margin-left: 10%; color: orange; margin-top: 2%"> 
              Samtools: high-throughput sequence data manipulation </h4>
            <ul class="bulletbox">
              <li class="items">Easy to install and run in seconds.</li>
              <li class="items">Composed of many microutilities in similar design to unix utilities</li>
              <li class="items">Bedtools: extract part of a genome; find overlaps between genome segments; etc.</li>
              <li class="items">Samtools: read/write/filter/edit SAM/BAM files of genomic data coordinates/stats</li>
              <li class="items">Simple instructions and examples: one-liners</li>
              <li class="items">Pipe multiple commands in different order to accomplish complex tasks</li>
            </ul>
          </div>
        </section>

        <!-- Cathedral -- finding the right run options , model, script is the goal -->
        <!-- Cathedral -- run once and then probably never again. -->
        <section>
          <div class="standard">
            <h3 class="title">Running a Cathedral Program</h3>
            <div class="textbox"><p style="text-align: center;">
              Call command on a script or config file: easy
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              program-name script
            </code></pre>                
            <!--  -->
            <div class="textbox"><p>
              The hard part is designing the script/instructions. Finding the right options/code/model/instructions
              to setup the program correctly *is the goal*. You will probably only run this once and then be done 
              with it.
            </p></div>       
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title">Running a Bazaar Program</h3>
            <div class="textbox"><p style="text-align: center;">
              Call many simple commands with options piped from one to next; each one simple task
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # perform simple task 'a'
              prog -a data

              # perform simple task 'b'
              prog -b data

              # or, perform complex task by combining commands
              prog -a data | prog -b - | prog -c - > output.csv
            </code></pre>
            <!--  -->
            <div class="textbox"><p>
              Each program is easy to understand, and in different combinations can accomplish 
              complex tasks. Easy to debug. Can be confusing to know what all is possible, and
              how to accomplish it.
            </p></div>       
          </div>
        </section>
      </section>

    <!-- =================================================================================================================== -->
    <!-- ===== DEV TIPS ==================================================================================================== -->
    <!-- =================================================================================================================== -->        

      <section>
        <section>
          <div class="standard">
            <h3 class="title">Dev tips 1: design for the style of use</h3>
            <div class="textbox"><p>
            Will the user only interact with the program once? (e.g., genome assembly)</p></div>
            <ul class="bulletbox">
              <li class="items">Checkpointing to restart if interrupted.</li>
              <li class="items">Progress bar for indication.</li>
              <li class="items">Log file of the parameters/settings used.</li>
              <li class="items">Designed to run in terminal (e.g., on a server).</li>
            </ul>
            <br>
            <div class="textbox"><p>
              Or will they use the program interactively, tweaking options? (e.g., plotting tools)
            </p></div>
            <ul class="bulletbox">
              <li class="items">Fast and responsive.</li>
              <li class="items">Auto-completion (tab) support (cleaned).</li>
              <li class="items">Designed to run in interactive env (e.g., jupyter, RStudio).</li>
            </ul>
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title5">CLI vs API</h3>
            <div class="textbox"><p>
              The design of a program can generate tradeoffs between efficiency
              and reproducibility, accessibility, and ‘activation energy’. CLI
              (command line interface) vs API (application programming interface)
              provide a nice example of this.
            </p></div>
          </div>
        </section>

        <section>
          <div class="standard">
            <h3 class="title5">CLI</h3>
            <div class="textbox"><p style="text-align: center;">
              We are now familiar with the format of command-line tools
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              prog -b 10 -c 4 --mode "fast" data > out.txt
            </code></pre>
            <ul class="bulletbox">
              <li class="items">Pro: Fast to execute</li>
              <li class="items">Pro: Can often interact (e.g., pipe) with other unix tools</li>
              <li class="items">Con: Slow and burdensome to generate and view visualizations</li>
              <li class="items">Con: Extra work to further analyze results in Python or R</li>
            </ul>
          </div>
        </section>        


        <section>
          <div class="standard">
            <h3 class="title5">API</h3>
            <div class="textbox"><p>
              An API is implemented within a programming language (e.g., Python or R) and
              allows easy interactions between the specific software program and the general
              use of that language.
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # First open an interactive Python session
              ipython
            </code></pre>
            <pre style="width:60%"><code data-trim class="language-python">
              >>> # Then within Python the code can be run
              >>> import toytree
              >>> tree = toytree.rtree.bdtree(ntips=10)
              >>> print(tree.ntips)
            </code></pre>            

            <ul class="bulletbox">
              <li class="items">Pro: Can combine general scripting with the specific API commands</li>
              <li class="items">Pro: Visual tools/libraries are highly developed and integrated (e.g., jupyter)</li>
              <li class="items">Con: Slower to access the program, requiring writing a script or opening interactive session</li>
              <li class="items">Con: To benefit from an API requires some knowledge of the language</li>
            </ul>
          </div>
        </section>


        <section>
          <div class="standard">
            <h3 class="title5">CLI vs API example on the same tool</h3>
            <div class="textbox"><p>
              Many tools are developed as both a CLI and API. The API allows the developer
              or users a convenient framework for accessing utilities of the software; and
              the CLI provides easy access to a few simple and commonly used commands.
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # call the program `ms` from the command line to simulate coalescent trees
              $ ms 15 1000 -t 6.4 -G 6.93 -eG 0.2 0.0 -eN 0.3 0.5
            </code></pre>
            <pre style="width:60%"><code data-trim class="language-python">
              >>> # use the msprime API in Python to setup the same simulation
              >>> import msprime
              >>> d = msprime.Demography()
              >>> d.add_population(name="A", initial_size=20000, growth_rate=6.4)
              >>> d.add_population_parameters_change(time=16000, growth_rate=0.0)
              >>> d.add_population_parameters_change(time=24000, initial_size=10000)
              >>> ts = msprime.sim_ancestry(samples={"A": 15}, demography=d)
            </code></pre>
          </div>
        </section>        
      </section>        

      <section>
        <section>
          <div>
            <h3 class="title">Dev tips 2: build upon existing tools</h3>
            <div class="textbox"><p>
            Most problems have some existing tool designed to address them. When thinking about
            starting a new project ask yourself the following questions:
            </p></div>
            <ul class="bulletbox">
              <li class="items">Is there need for a newer or better tool?</li>
              <li class="items">Should I rewrite or extend the existing tool?</li>
              <li class="items">Should I contribute to that tool, or write a "wrapper/pipeline" that uses it?</li>
              <li class="items">Who is the community that will use these tools?</li>
            </ul>
          </div>
        </section>

        <section>
          <div>
            <h3 class="title5">Wrapper tools</h3>
            <div class="textbox"><p>
              Sometimes a tool accomplishes a single task well, but is poorly designed for a related
              task. A <b>wrapper tool</b> is a program that calls the first program in a new and different
              enough way that it is worth packaging as a separate tool.
              <br>
              <br>
              Example: <i>easySFS</i> developed by Isaac Overcast is a Python-based wrapper that
              calls the program <i>dadi</i> in an iterative way -- as opposed to just once -- in a 
              way that allows exploring a broad parameter space to find the settings that maximize
              the data quality. Because users may want to perform this iterative process in different
              ways, easySFS provides its own user interface:
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              $ ./easySFS.py -i input.vcf -p pops_file.txt --preview
            </code></pre>
            <pre style="width:60%"><code data-trim class="language-bash">            
              Pop1
              (2, 45.0)   (3, 59.0)   (4, 58.0)   (5, 49.0)   (6, 41.0)   (7, 35.0)   (8, 27.0)   (9, 20.0)   (10, 13.0)  (11, 8.0)   (12, 8.0)   (13, 5.0)   (14, 2.0)   (15, 2.0)   (16, 1.0)   

              pop2
              (2, 68.0)   (3, 96.0)   (4, 106.0)  (5, 110.0)  (6, 108.0)  (7, 89.0)   (8, 76.0)   (9, 66.0)   (10, 56.0)  (11, 49.0)  (12, 42.0)  (13, 39.0)  (14, 34.0)  (15, 29.0)  (16, 27.0)  (17, 26.0)  (18, 24.0)  (19, 23.0)  (20, 21.0)  (21, 22.0)  (22, 20.0)  (23, 19.0)  (24, 16.0)  (25, 16.0)  (26, 15.0)  (27, 15.0)  (28, 13.0)  (29, 13.0)  (30, 14.0)  (31, 14.0)  (32, 14.0)  (33, 13.0)  (34, 12.0)  (35, 9.0)   (36, 9.0)   (37, 8.0)   (38, 8.0)   (39, 8.0)   (40, 6.0)   (41, 6.0)   (42, 6.0)   (43, 5.0)   (44, 5.0)   (45, 5.0)   (46, 4.0)   (47, 4.0)   (48, 4.0)   (49, 3.0)   (50, 3.0)   (51, 3.0)   (52, 3.0)   (53, 3.0) 
            </code></pre>
          </div>
        </section>

        <section>
          <div>
            <h3 class="title5">Wrapper tools</h3>
            <div class="textbox"><p>
              Wrappers are a great place to start out in programming because they reduce the complexity
              of the problem to one of iteration, aggregation, and evaluation of results, instead of 
              starting with trying to develop novel algorithms. Often they are very useful tools for
              your own research. If you think they will be helpful to others, share it on GitHub!
              <br><br>
              We will learn the building blocks necessary to write a wrapper tool within the first week
              of learning Python.
            </p></div>
          </div>
        </section>
      </section>



      <section>
        <section>
          <div>
            <h3 class="title5">Dev tips 3: design and organize</h3>
            <div class="textbox"><p>
              Avoid the "scientific software as a pile of scripts" trap. Many scientific
              software tools are distributed as simply a collection of one-off scripts. This
              is very different from organizing a cohesive Bazaar-style software tool with 
              atomic functions. 
            </p></div>
            <pre style="width:60%"><code data-trim class="language-bash">
              # run the four steps of scientific pipeline X
              # 1. make the input files
              $ convertIM.pl infile.list
              # 2. Observed summary statistics vector
              $ obsSumStats.pl -T obsSS.table batch.masterIn.fromIM > obsSS.txt
              # 3. Simulating the prior
              $ msbayes.pl -c batch.masterIn.fromIM  -r 1000000 -o priorfile
              # 4. Getting the posterior
              $ acceptRej.pl -t 0.001 -p outfig.pdf obsSS.txt priorfile > modeEstimatesOut.txt
              # 5. Create plots in R
              $ Rscript make_plots_of_model_outputs_1.R modeEstimatesOut.txt
              $ Rscript make_plots_of_model_outputs_2.R modeEstimatesOut.txt              
            </code></pre>            
            <ul class="bulletbox">
              <li class="items">Pros: easy to develop</li>
              <li class="items">Pros: Gets the job done (at least once)</li>
              <li class="items">Cons: Fragile (dependent on many other tools and languages that will likely change)</li>
              <li class="items">Cons: Poor documentation and readability</li>
              <li class="items">Cons: Unlikely to be used by others</li>              
            </ul>
          </div>
        </section>

        <section>
          <div>
            <h3 class="title5">Dev tips 3: design and organize</h3>
            <div class="textbox"><p>
              Why don't more software tools have a graphical interface?</p></div>
            <ul class="bulletbox">
              <li class="items">Pros: User friendly</li>
              <li class="items">Pros: "wow" factor of visual results</li>
              <li class="items">Pros: supports exploratory and educational analysis</li>
              <li class="items">Cons: Doesn't scale well to super large data </li>
              <li class="items">Cons: Difficult to run on HPC clusters</li>
              <li class="items">Cons: Not reproducible</li>
              <li class="items">Cons: Difficult to implement (many steps)</li>
            </ul>
            <div class="textbox"><p>
              Jupyter Notebook and R Studio type tools provide a Happy Medium.
              </p></div>
            <ul class="bulletbox">
              <li class="items">Pros: User friendly</li>
              <li class="items">Pros: "wow" factor of visual results</li>
              <li class="items">Pros: supports exploratory and educational analysis</li>
              <li class="items">Pros: Can scale to super large data and run on HPCs</li>
              <li class="items">Pros: Reproducible</li>
              <li class="items">Pros: Developers do not need to learn complicated GUI frameworks</li>
            </ul>            
          </div>
        </section>        
      </section>

    <!-- =================================================================================================================== -->
    <!-- ===== IPYRAD EXAMPLE ==================================================================================================== -->
    <!-- =================================================================================================================== -->     

      <section>
        <section>
          <div class="standard">
            <h3 class="title">Example: design motivation behind ipyrad</h3>
            <div class="textbox"><p>
            Genomic assembly software for RAD-seq type data. Two tools took fairly 
            different design approaches. 

            Stacks follows the design of a unix type program, requiring the
            user to enter all arguments individually to several atomized sub-programs. 
            The authors provide bash script templates (e.g., for-loops) to run the 
            entire workflow, composing many steps. It is easy for a typo or bug in 
            the script to crash the whole workflow.
            <br><br>
            ipyrad is also designed as a command line tool, but takes a single params
            file as input, in which the user can enter all parameters. ipyrad then 
            creates the full workflow, managing all files from one atomic 
            subprogram to the next.
            </p></div>
          </div>
        </section>

        <section>
          <div class="standard">
            <div class="textbox"><p>
            Stacks bash script requires user to enter every sample name <i>by hand</i>! and to write for-loops, and call several tools, to run just part of the workflow.
            </p></div>
          </div>
          <pre style="width:60%"><code data-trim class="language-bash">
            #!/bin/bash

            src=$HOME/research/project

            files=”sample_01
            sample_02
            sample_03”

            #
            # Build loci de novo in each sample for the single-end reads only. If paired-end reads are available, 
            # they will be integrated in a later stage (tsv2bam stage).
            # This loop will run ustacks on each sample, e.g.
            #   ustacks -f ./samples/sample_01.1.fq.gz -o ./stacks -i 1 --name sample_01 -M 4 -p 8
            #
            id=1
            for sample in $files
            do
                ustacks -f $src/samples/${sample}.1.fq.gz -o $src/stacks -i $id --name $sample -M 4 -p 8
                let "id+=1"
            done

            # 
            # Build the catalog of loci available in the metapopulation from the samples contained
            # in the population map. To build the catalog from a subset of individuals, supply
            # a separate population map only containing those samples.
            #
            cstacks -n 6 -P $src/stacks/ -M $src/popmaps/popmap -p 8

            #
            # Run sstacks. Match all samples supplied in the population map against the catalog.
            #
            sstacks -P $src/stacks/ -M $src/popmaps/popmap -p 8

            #
            # Run tsv2bam to transpose the data so it is stored by locus, instead of by sample. We will include
            # paired-end reads using tsv2bam. tsv2bam expects the paired read files to be in the samples
            # directory and they should be named consistently with the single-end reads,
            # e.g. sample_01.1.fq.gz and sample_01.2.fq.gz, which is how process_radtags will output them.
            #
            tsv2bam -P $src/stacks/ -M $src/popmaps/popmap --pe-reads-dir $src/samples -t 8

            #
            # Run gstacks: build a paired-end contig from the metapopulation data (if paired-reads provided),
            # align reads per sample, call variant sites in the population, genotypes in each individual.
            #
            gstacks -P $src/stacks/ -M $src/popmaps/popmap -t 8

            #
            # Run populations. Calculate Hardy-Weinberg deviation, population statistics, f-statistics
            # export several output files.
            #
            populations -P $src/stacks/ -M $src/popmaps/popmap -r 0.65 --vcf --genepop --structure --fstats --hwe -t 8
          </code></pre>
        </section>

        <section>
          <div class="standard">
            <div class="textbox"><p>
              By contrast, ipyrad allows users to set all parameters in a single file, to run the entire assembly in one command.
            </p></div>
          </div>
          <pre style="width:60%"><code data-trim class="language-bash">
            # create a default parameter file
            ipyrad -n test

            # run all steps of the assembly using setting in params-test.txt
            ipyrad -p params-test.txt -s 1234567
          </code></pre>
          <br>
          <div class="standard">
            <div class="textbox"><p>
              And if the user wants to test different parameter settings, you can
              create a branched at a checkpoint (1-7) and continue from that
              point with different parameters.
            </p></div>                        

          <pre style="width:60%"><code data-trim class="language-bash">
            # create a default parameter file
            ipyrad -p params-test.txt -b newparams

            # run all steps of the assembly using setting in params-test.txt
            ipyrad -p newparams-test.txt -s 67
          </code></pre>
        </section>

        <section>
          <div class="standard">
            <h3 class="title5">CLI and API</h3>
            <div class="textbox"><p>
              For downstream (and visual) analyses, we created a Python API:
              the ipyrad-analysis toolkit. This allows users to install one 
              package that supports long-running CLI commands, and fast and
              interactive downstream analyses.
            </p></div>
          </div>
          <pre style="width:60%"><code data-trim class="language-python">
            # run a structure analysis wrapper over 10 reps and visualize results
            >>> import ipyrad.analysis as ipa
            >>> tool = ipa.structure(data="./data.vcf", min_maf=0.1, min_cov=10)
            >>> tool.run(reps=10)
            >>> tool.draw_barplot()
          </code></pre>
        </section>
      </section>


		</div>
	</div>
	
	<script src="../revealjs/dist/reveal.js"></script>
	<script src="../revealjs/plugin/notes/notes.js"></script>
	<script src="../revealjs/plugin/highlight/highlight.js"></script>
	<script src="../revealjs/plugin/markdown/markdown.js"></script>	
	<script>
		Reveal.initialize({
			transition: 'none',
			hash: true,
			plugins: [RevealNotes, RevealHighlight, RevealMarkdown],
			width: 1600,
			height: 900,
			minScale: 0.1,
			maxScale: 5,
			controls: true,
			progress: true,
			loop: false,
			center: false,
		});
	</script>
</body>
</html>
